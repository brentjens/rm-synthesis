#!/usr/bin/env python2
# -*- python -*-

from getopt import gnu_getopt as getopt
from getopt import GetoptError
import os, sys, time

from rmsynthesis.main import ShapeError, ParseError, compute_rmsf, write_rmsf
from rmsynthesis.main import file_exists, proper_fits_shapes, parse_frequency_file
from rmsynthesis.main import wavelength_squared_m2_from_freq_hz
from rmsynthesis.main import rmsynthesis_dirty_lowmem_main
from rmsynthesis.main import RMSYNTHESIS_VERSION

from numpy import arange, array, ceil, sqrt


def warn(msg):
    print('')
    print('|------------------------------------------------------------------------------|')
    print('| WARNING: '+msg)
    print('|------------------------------------------------------------------------------|')
    print('')
    wrong_answer = True
    answer       = ''
    while wrong_answer:
        sys.stdout.write('Do you wish to continue (yes, I do/no)>>> ')
        answer       = sys.stdin.readline().strip()
        wrong_answer = answer not in ['yes, I do', 'no']
        if len(answer)> 15:
            sys.stdout.write('>>> stop babbling')
            if answer[0:9] == 'yes, I do':
                sys.stdout.write('! I will continue, though. <<<\n')
                wrong_answer = False
                answer = answer[0:9]
            else:
                sys.stdout.write(', and answer the question! <<<\n')
            time.sleep(2)
    if answer == 'yes, I do':
        return True
    else:
        exit(-1)


def print_summary(argv, **kwargs):
    global RMSYNTHESIS_VERSION
    key_width = 15
    def prkv(key, value):
        print(key.ljust(key_width)+': '+str(value))

    print('')
    print('RM synthesis %s summary' % RMSYNTHESIS_VERSION)
    print('------------------------')
    print('')
    print('Command'.ljust(key_width)+': '+' '.join(argv))
    print('Working dir'.ljust(key_width)+': '+os.getcwdu())
    print('Max mem'.ljust(key_width)+': '+'%.1f GB' % kwargs['max_mem_gb'])
    print('')

    prkv('Q cube', kwargs['qname'])
    prkv('U cube', kwargs['uname'])
    prkv('Frequencies', kwargs['frequencyname'])
    prkv('Output dir', kwargs['output_dir'])
    prkv('Force overwrite', kwargs['force_overwrite'])
    prkv('Check only', kwargs['check'])
    print('')
    prkv('Low phi', kwargs['low_phi'])
    prkv('High phi', kwargs['high_phi'])
    prkv('Delta phi', kwargs['dphi'])
    print('')
    prkv('RM cube', kwargs['rmcube_name'])
    prkv('RMSF', kwargs['rmsf_name'])
    prkv('Log file', kwargs['log_name'])
    print('')


def print_help():
    print("""Usage
-----

  rmsynthesis [options] <Q-directory> <U-directory>

or

  rmsynthesis [options] <Qcube.fits> <Ucube.fits> <frequencies.txt>

  -o/--output <directory>    Output directory (Default: .)

  -l/--low <phi>             Lowest Faraday depth in output cube.
                             Default value is
                             -sqrt(3)/delta (lambda^2),
                             where delta (lambda^2) is the smallest
                             one as computed from the frequency list.

  -h/--high <phi>            Highest Faraday depth in output cube.
                             Default value is
                             +sqrt(3)/delta (lambda^2),
                             where delta (lambda^2) is the smallest
                             one computed from the frequency list.

  -d/--dphi <delta phi>      Faraday depth increment between frames
                             from the RM cube. Default value is
                             sqrt(3)/Delta (lambda^2), where Delta
                             (lambda^2) is max(lambda^2) -
                             min(lambda^2), computed from the
                             frequency list.

  -f/--force                 Force overwriting files in output
                             directory if they already exist.

  -c/--check                 Perform all possible checks, but do not
                             write any files or compute an RM cube.

  -q/--qfactor <qf>          Factor to multiply values in Q cube with,
                             Default value is 1.0

  -u/--ufactor <uf>          Factor to multiply values in U cube with,
                             Default value is 1.0. For WSRT data, this
                             factor must be 1.2 if it has not already
                             been applied.

  -m/--max-mem <GB>          Maximum amount of memory to be used in GB.
                             Default is %.1f GB.

  -v/--version               Display version information.


Input
-----

The Q and U fits cubes are required and must have three axes. The
fastest varying axis (AXIS1) must be right ascension, the second axis
(AXIS2) declination, and the slowest varying axis (AXIS3) is the frame
number. The rmsynthesis script ignores frequency information in the
FITS cubes. It only uses frequency information provided in the text
file. Note that the order of the axes in Python/numpy is the reverse
of that in the FITS file. That is, in Python, the first axis (axis 0)
is the slowest varying axis. The pyfits library transparently handles
this conversion. Note that the Q and U cubes must be similar in the
sense that their shape and scales (ra, dec, and frame number) must be
the same.

The third required input is the list of frequencies. This must be a
text file with one frequency per line. The frequency must be in Hz and
can be either an integer or a floating point number. A (tiny) example:

1.420e9
1680000000
4800000000


Output
------

The output files are written in the current working directory, unless
otherwise specified with the -o option.

- p-rmcube-dirty.fits FITS cube with axis RA (AXIS1), Dec (AXIS2),
                      Faraday depth (AXIS3). Total linear polarization.

- q-rmcube-dirty.fits FITS cube with axis RA (AXIS1), Dec (AXIS2),
                      Faraday depth (AXIS3). Derotated Q.

- u-rmcube-dirty.fits FITS cube with axis RA (AXIS1), Dec (AXIS2),
                      Faraday depth (AXIS3). Derotated U.

- rmsf.txt            Text file with the RM spread function. The first
                      column is Faraday depth, the second column the
                      response parallel to the original polarization
                      direction (\"q\"), and the third column the
                      response at 45 degrees with respect to the
                      original polarization direction (\"u\").

- rmsynthesis.log     Contains the command line options used to obtain
                      this output.
""" % max_memory_gb())
    return -1



def max_memory_gb(fraction=0.8):
    r'''
    Determine the maximum amount of memory available for RM synthesis
    '''
    if os.path.exists('/proc/meminfo'):
        words = [line for line in open('/proc/meminfo').readlines()
                 if 'MemTotal'.lower() in line.lower()][0].split()[1:]
        mem   = float(words[0])
        if words[1] == 'kB':
            mem *= 1024
        else:
            raise ValueError('Do not know how to handle memory in %s' % words[1])
        return fraction*mem/(1024**3)
    else:
        return 3.0






#
#  MAIN routine
#


def main(argv):
    global RMSYNTHESIS_VERSION
    if len(argv) == 1:
        return print_help()
    options, arguments = getopt(argv[1:],
                                'o:l:h:d:q:u:fcvm:',
                                ['output=',
                                 'low=',
                                 'high=',
                                 'dphi=',
                                 'qfactor=',
                                 'ufactor=',
                                 'max-mem=',
                                 'force',
                                 'check',
                                 'version'])

    # Default values

    output  = '.'
    low     = None
    high    = None
    dphi    = None
    force_overwrite = False
    check   = False
    dphi_user_override = False
    qfactor = 1.0
    ufactor = 1.0
    max_mem_gb = max_memory_gb(fraction = 0.8)

    for (option, value) in options:
        if   option in ['-o', '--output']:
            output = value
        elif option in ['-l', '--low']:
            low = float(value)
        elif option in ['-h', '--high']:
            high = float(value)
        elif option in ['-d', '--dphi']:
            dphi = float(value)
            dphi_user_override = True
        elif option in ['-q', '--qfactor']:
            qfactor = float(value)
        elif option in ['-u', '--ufactor']:
            ufactor = float(value)
        elif option in ['-m', '--max-mem']:
            max_mem_gb = float(value)
        elif option in ['-f', '--force']:
            force_overwrite = True
        elif option in ['-c', '--check']:
            check = True
        elif option in ['-v', '--version']:
            print('rmsynthesis %s (c) 2005-2013 M.A. Brentjens <brentjens@astron.nl>' %
                  RMSYNTHESIS_VERSION)
            exit(0)

    if len(arguments) != 3:
        raise GetoptError(
            'error: provide Q and U FITS cubes and a frequency text file')

    files_exist = [file_exists(arg, verbose = True) for arg in arguments]
    if not all(files_exist):
        print(
            'error: provide Q and U FITS cubes and a frequency text file')
        return -1

    qname, uname, frequencyname = arguments
    if qname == uname:
        warn('Q name ('+qname+') and U name ('+uname+' are the same')
    if frequencyname[-4:].lower() == 'fits':
        warn('Frequency file ('+frequencyname+') might be a fits file')

    frequencies  = parse_frequency_file(frequencyname)
    wl2          = wavelength_squared_m2_from_freq_hz(frequencies)
    sorted_wl2   = array(sorted(wl2))
    smallest_dl2 = min(abs(sorted_wl2[1:] - sorted_wl2[0:-1]))
    if abs(smallest_dl2) == 0.0:
        print('error: two frames have equal frequency')
        return -1

    if low is None:
        low = -sqrt(3)/smallest_dl2

    if high is None:
        high = +sqrt(3)/smallest_dl2

    if dphi is None:
        dphi = abs(sqrt(3)/(sorted_wl2[-1]-sorted_wl2[0]))

    # Normalize dphi so that there is an integer number
    # of frames between low and high (inclusive)
    if not dphi_user_override:
        if low < 0 and high > 0:
            lowframes = ceil(abs(0-low)/dphi)
            dphi = abs((0-low)*(1.0-1e-15)/(lowframes+1))
        else:
            ValueError('error: low phi limit ('+str(low)+
                       ') must be negative and high phi limit ('+str(high)+
                       ') positive')

    if qfactor == 0:
        warn('Q factor is 0.0')
    if ufactor == 0:
        warn('U factor is 0.0')
    if max_mem_gb < 0.5:
        warn('Maximum allowed memory is < 500 MB')

    rmcube_name = os.path.join(output, '{p-,q-,u-}rmcube-dirty.fits')
    rmsf_name   = os.path.join(output, 'rmsf.txt')
    log_name    = os.path.join(output, 'rmsynthesis.log')

    phi = arange(low, high+dphi*0.1, dphi)


    def summary():
        print_summary(argv,
                      qname         = qname,
                      uname         = uname,
                      frequencyname = frequencyname,
                      output_dir    = output,
                      low_phi       = low,
                      high_phi      = high,
                      dphi          = dphi,
                      force_overwrite = force_overwrite,
                      rmcube_name   = rmcube_name,
                      rmsf_name     = rmsf_name,
                      log_name      = log_name,
                      check         = check,
                      max_mem_gb    = max_mem_gb)

    summary()

    if not file_exists(output):
        print('output dir '+output+' does not yet exist; it will be created')

    if file_exists(log_name):
        if force_overwrite:
            print('warning: file %s already exists; it will be overwritten' %
                  log_name)
        else:
            print('error: file %s already exists; use --force to overwrite' %
                  log_name)
            return -1

    if not proper_fits_shapes(qname, uname, frequencyname):
        return -1

    # Write log file

    if not check:
        if not file_exists(output):
            os.mkdir(output)
        saveout    = sys.stdout
        sys.stdout = open(log_name, 'w')
        summary()
        sys.stdout.close()
        sys.stdout = saveout


    # Finally, do the work...

    if not check:
        rmsynthesis_dirty_lowmem_main(qname,   uname,
                                      qfactor, ufactor,
                                      output, frequencies,
                                      phi, force_overwrite,
                                      max_mem_gb)
        rmsf = compute_rmsf(frequencies, phi)
        write_rmsf(phi, rmsf, output)
    return 0




if __name__ == "__main__":
    try:
        exit(main(sys.argv))
    except (OSError, IOError):
        print('error: '+str(sys.exc_info()[1]))
        exit(-1)
    except (GetoptError, ParseError, ShapeError):
        print(sys.exc_info()[1])
        print('use "'+sys.argv[0]+'" for help.')
        exit(-1)
    except (MemoryError, ):
        print(sys.exc_info()[1])
        print('The input or output cubes are too large to handle at the moment. They do ')
        print('not fit in memory together with the intermediate results. Please make the')
        print('cubes smaller or kindly ask the author for an upgrade.')
        print('use "'+sys.argv[0]+'" for help.')
        exit(-1)
    except (KeyboardInterrupt, ):
        print('')
        exit(-1)
